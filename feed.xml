<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://iliasslasri.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://iliasslasri.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-12-17T11:51:45+00:00</updated><id>https://iliasslasri.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">NMF Divergence Derivation by ME</title><link href="https://iliasslasri.github.io/blog/2024/nmf/" rel="alternate" type="text/html" title="NMF Divergence Derivation by ME"/><published>2024-12-10T09:30:00+00:00</published><updated>2024-12-10T09:30:00+00:00</updated><id>https://iliasslasri.github.io/blog/2024/nmf</id><content type="html" xml:base="https://iliasslasri.github.io/blog/2024/nmf/"><![CDATA[<p>The objective here is to minimize the Kullback-Leibler (KL) divergence between the original data matrix \(V\)and its approximation\(WH\):</p> \[D(V||WH) = \sum_{f,t} \left( V_{ft} \log \frac{V_{ft}}{(WH)_{ft}} - V_{ft} + (WH)_{ft} \right)\] <p>Where:</p> <ul> <li>\(V\)is the data matrix of size\(n \times m\)</li> <li>\(W\)is the basis matrix of size\(n \times K\)</li> <li>\(H\)is the activation matrix of size\(K \times m\)</li> </ul> <p>For a fixed \(H\), we can minimize the divergence with respect to \(W\) by computing the gradient:</p> \[\frac{\partial D(V||WH)}{\partial W}\] <p>Let’s compute the gradient of the divergence with respect to a single element \(W_{fk}\):</p> \[\frac{\partial D(V||WH)}{\partial W_{fk}} = \sum_{t} \left( \left( - \frac{V_{ft}}{(WH)_{ft}} + 1 \right) H_{kt}\right)\] <p>Now, supposing that we have the following gradient descent update rule for \(W\)with a learning rate\(\lambda\):</p> \[W_{fk} \leftarrow W_{fk} - \lambda_{k} \frac{\partial D(V||WH)}{\partial W_{fk}}\] <p>Because this is a constrained optimization problem (matrices \(W\)and\(H\) must remain non-negative), we use a specialized learning rate. Substituting the gradient into the update rule gives:</p> \[W_{fk} \leftarrow W_{fk} + \lambda_{k} \sum_{t} \left( \left( \frac{V_{ft}}{(WH)_{ft}} - 1 \right) H_{kt} \right)\] <p>To derive the multiplicative update rule, we choose a specific, adaptive learning rate \(\lambda_{k}\) such that the subtraction terms cancel out:</p> \[\lambda_{k} = \frac{W_{fk}}{\sum_{t} H_{kt}}\] <p>Substituting this \(\lambda_k\) back into our update equation:</p> \[W_{fk} \leftarrow W_{fk} + \frac{W_{fk}}{\sum_{t} H_{kt}} \sum_{t} \left( \left( \frac{V_{ft}}{(WH)_{ft}} - 1 \right) H_{kt} \right)\] <p>Distributing the terms inside the summation:</p> \[W_{fk} \leftarrow W_{fk} + \frac{W_{fk}}{\sum_{t} H_{kt}} \sum_{t} \left( \frac{V_{ft}H_{kt}}{(WH)_{ft}} - H_{kt} \right)\] <p>Splitting the summation:</p> \[W_{fk} \leftarrow W_{fk} + \frac{W_{fk}}{\sum_{t} H_{kt}} \left( \sum_{t} \left( \frac{V_{ft}H_{kt}}{(WH)_{ft}}\right) - \sum_{t} H_{kt} \right)\] <p>Distributing the fraction:</p> \[W_{fk} \leftarrow W_{fk} + \left( \frac{W_{fk}}{\sum_{t} H_{kt}} \sum_{t} \left( \frac{V_{ft}H_{kt}}{(WH)_{ft}}\right) - \frac{W_{fk}}{\sum_{t} H_{kt}} \sum_{t} H_{kt} \right)\] <p>Notice that in the second term, \(\sum_{t} H_{kt}\) cancels out:</p> \[W_{fk} \leftarrow W_{fk} + \frac{W_{fk}}{\sum_{t} H_{kt}} \sum_{t} \left( \frac{V_{ft}H_{kt}}{(WH)_{ft}}\right) - W_{fk}\] <p>The \(+ W_{fk}\)and\(- W_{fk}\)cancel each other out, leaving us with the final Multiplicative Update Rule for\(W\):</p> \[W_{fk} \leftarrow \frac{W_{fk}}{\sum_{t} H_{kt}} \sum_{t} \left( \frac{V_{ft}H_{kt}}{(WH)_{ft}}\right)\] <p>Or, in matrix notation:</p> \[W \leftarrow W \otimes \frac{\frac{V}{WH} H^T}{\mathbf{1} H^T}\]]]></content><author><name></name></author><category term="derivations"/><category term="math"/><category term="machine-learning"/><category term="nmf"/><category term="optimization"/><summary type="html"><![CDATA[A step-by-step derivation of the Multiplicative Update Rule for Non-negative Matrix Factorization using KL-Divergence.]]></summary></entry><entry><title type="html">Mimi: The Codec behind Moshi and Unmute</title><link href="https://iliasslasri.github.io/blog/2024/mimi/" rel="alternate" type="text/html" title="Mimi: The Codec behind Moshi and Unmute"/><published>2024-07-20T13:00:00+00:00</published><updated>2024-07-20T13:00:00+00:00</updated><id>https://iliasslasri.github.io/blog/2024/mimi</id><content type="html" xml:base="https://iliasslasri.github.io/blog/2024/mimi/"><![CDATA[<p><img src="../img/mimi_arch.avif" alt="Mimi architecture diagram"/></p> <p><a href="https://kyutai.org/Moshi.pdf">Official Paper</a> for reference. Minimal environment setup to use Mimi can be found <a href="https://github.com/iliasslasri/mimi">in my repo</a>.</p> <h2 id="the-scope-of-this-post">The Scope of this Post</h2> <p>Today we are going to explore Mimi, a state-of-the-art neural audio codec developed by Kyutai. We will compare audio quality before and after Mimi processing, and we will then study how Mimi works and what types of outputs it produces.</p> <h2 id="what-is-mimi">What is Mimi?</h2> <blockquote> <p>“Mimi codec is a state-of-the-art audio neural codec, developed by Kyutai, that combines semantic and acoustic information into audio tokens running at 12Hz and a bitrate of 1.1kbps.”</p> </blockquote> <p>This is the official description of Mimi from Kyutai’s Huggingface repo. Mimi is also the neural audio codec that powers Moshi (a demo is currently available on <a href="https://moshi.chat">moshi.chat</a>), which we may discuss in a future post.</p> <h2 id="what-is-a-neural-audio-codec">What is a Neural Audio Codec?</h2> <p>First, let’s define a codec: A codec, short for “coder-decoder” or “compressor-decompressor”, is a device or computer program that encodes or decodes a digital data stream or signal.</p> <p>The primary purposes of codecs are to:</p> <ul> <li>Reduce file size for efficient storage</li> <li>Decrease bandwidth requirements for transmission</li> <li>Maintain an acceptable level of quality</li> </ul> <p>An audio codec is a codec that encodes or decodes audio data. There exist two types of audio codecs:</p> <ul> <li><strong>Lossy audio codecs:</strong> These compress audio by removing some data, resulting in smaller file sizes but with some loss in quality (e.g., MP3, AAC).</li> <li><strong>Lossless audio codecs:</strong> These compress audio without losing any original data, maintaining perfect quality but with larger file sizes compared to lossy codecs (e.g., FLAC, ALAC).</li> </ul> <p>A neural audio codec is a type of audio codec that leverages DNNs, neural networks in particular, to compress and decompress audio signals. Some examples include:</p> <ul> <li><strong>Lyra:</strong> Developed by Google, designed for low-bitrate speech compression.</li> <li><strong>EnCodec:</strong> Created by Meta AI, a high-fidelity neural audio codec.</li> <li><strong>SoundStream:</strong> Another Google codec focusing on high-quality audio compression at low bitrates.</li> </ul> <p>Mimi’s architecture is mostly derived from SoundStream and EnCodec, as stated in the <a href="https://kyutai.org/Moshi.pdf">official paper</a>, although it has some novel features that set it apart.</p> <h2 id="mimi-in-detail">Mimi in Detail</h2> <p>As mentioned earlier, Mimi is a neural audio codec that combines semantic and acoustic information into audio tokens running at 12Hz and a bitrate of 1.1kbps.</p> <p>However, there is a slight discrepancy: the actual implementation of Mimi runs at <strong>12.5Hz</strong>, as stated in the paper and in the official <code class="language-plaintext highlighter-rouge">config.json</code> file (under <code class="language-plaintext highlighter-rouge">frame_rate</code>). Apart from that, Mimi is a fascinating codec that produces high-quality audio at an incredibly low bitrate.</p> <p>Being an audio codec, Mimi is composed of two main components which form a bottleneck architecture:</p> <ol> <li><strong>An encoder:</strong> Takes an audio signal as input and compresses it into a smaller representation.</li> <li><strong>A decoder:</strong> Takes the compressed representation and reconstructs the audio signal.</li> </ol> <h3 id="the-encoding-process">The Encoding Process</h3> <p>The encoder compresses the audio signal into a sequence of audio codes, split into semantic and acoustic audio tokens. Here’s how it works:</p> <ul> <li>The audio signal is split into frames, each lasting 0.08 seconds (12.5Hz frame rate).</li> <li>Each frame is passed through a convolutional neural network (CNN) and a transformer, which convert the frame into a vector of length 512.</li> <li>This vector is then passed through 8 quantizers.</li> </ul> <p>These quantizers produce 1 token per frame each:</p> <ul> <li><strong>1 quantizer</strong> for the semantic tokens. These represent the content/meaning of the audio and are trained to replicate semantic information obtained from a WavLM self-supervised audio model.</li> <li><strong>7 quantizers</strong> (according to the paper) for the acoustic tokens, which capture the style and details of the audio.</li> </ul> <p>The quantized audio tokens are concatenated to produce a tensor of shape <code class="language-plaintext highlighter-rouge">(batch_size, num_quantizers, sample_rate * length_audio)</code>.</p> <h3 id="bitrate-calculation">Bitrate Calculation</h3> <p>Let’s calculate the bitrate of Mimi based on the information provided using the following parameters:</p> <ul> <li>Frame rate: \(12.5 \text{ Hz}\)</li> <li>Number of audio tokens per frame: \(8\)</li> <li>Number of bits per audio token: \(\log_2(2048) = 11\) (since there are 2048 possible audio tokens)</li> </ul> <p>Therefore, the bitrate calculation is:</p> \[12.5 \times 8 \times 11 = 1100 \text{ bps} \text{ (or } 1.1 \text{ kbps)}\] <p><em>Note: Here we find another discrepancy. The paper states that there are 8 audio tokens per frame, but the official implementation produces 32 audio tokens per frame, and we can even set the number of levels in RQV as specified in <a href="https://github.com/kyutai-labs/moshi/issues/122">issue #122</a>.</em></p> <h3 id="the-decoding-process">The Decoding Process</h3> <p>The decoder takes the quantized tokens and reconstructs the audio signal following these steps:</p> <ol> <li>The tokens are passed through an inverse quantization process.</li> <li>The resulting embeddings are processed by another transformer network.</li> <li>Finally, a decoder CNN (mirroring the encoder’s CNN) reconstructs the audio waveform.</li> </ol> <h2 id="applications-of-mimi">Applications of Mimi</h2> <p>Mimi was primarily developed to power <strong>Moshi</strong>, a speech-to-speech AI model.</p> <p>Current chat models (like GPT) primarily operate on text tokens—discrete numerical representations of words. These models aren’t inherently designed to process audio data. Mimi bridges this gap by converting audio into discrete tokens, similar to how text is tokenized.</p> <p>This clever approach allows text-only models to support audio understanding and generation without requiring a complete overhaul of their architecture. Theoretically, we could fine-tune existing text-trained models to work with audio by teaching them to interpret these audio tokens alongside text tokens.</p> <h2 id="conclusions">Conclusions</h2> <p>Mimi represents a significant step forward in the field of neural audio codecs. Its ability to compress audio to incredibly low bitrates while maintaining good quality is impressive. The separation of semantic and acoustic information into distinct tokens is a novel approach that opens up new possibilities for audio processing.</p> <p>Using RQV is also a novel approach for quantization in codecs; check this for an implementation of RQV in <a href="https://github.com/lucidrains/vector-quantize-pytorch">PyTorch</a>.</p>]]></content><author><name></name></author><category term="technology"/><category term="audio"/><category term="ai"/><category term="deep-learning"/><category term="codecs"/><summary type="html"><![CDATA[A deep dive into Kyutai's state-of-the-art neural audio codec, exploring its architecture, quantization, and integration with LLMs.]]></summary></entry></feed>